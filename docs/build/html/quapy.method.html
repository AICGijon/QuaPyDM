

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>quapy.method package &#8212; QuaPy 0.1.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="quapy.data package" href="quapy.data.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quapy.data.html" title="quapy.data package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">QuaPy 0.1.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >quapy</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="quapy.html" accesskey="U">quapy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quapy.method package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="quapy-method-package">
<h1>quapy.method package<a class="headerlink" href="#quapy-method-package" title="Permalink to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-quapy.method.aggregative">
<span id="quapy-method-aggregative"></span><h2>quapy.method.aggregative<a class="headerlink" href="#module-quapy.method.aggregative" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.ACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">ACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ACC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier" title="quapy.method.aggregative.AggregativeQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeQuantifier</span></code></a></p>
<p><a class="reference external" href="https://link.springer.com/article/10.1007/s10618-008-0097-y">Adjusted Classify &amp; Count</a>,
the “adjusted” variant of <a class="reference internal" href="#quapy.method.aggregative.CC" title="quapy.method.aggregative.CC"><code class="xref py py-class docutils literal notranslate"><span class="pre">CC</span></code></a>, that corrects the predictions of CC
according to the <cite>misclassification rates</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.ACC.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_predictions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ACC.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.ACC.classify">
<span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ACC.classify" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the label predictions for the given instances. The predictions should respect the format expected by
<a class="reference internal" href="#quapy.method.aggregative.ACC.aggregate" title="quapy.method.aggregative.ACC.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a>, i.e., posterior probabilities for probabilistic quantifiers, or crisp predictions for
non-probabilistic quantifiers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray of shape <cite>(n_instances,)</cite> with label predictions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.ACC.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ACC.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a ACC quantifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the training set</p></li>
<li><p><strong>fit_classifier</strong> – set to False to bypass the training (the learner is assumed to be already fit)</p></li>
<li><p><strong>val_split</strong> – either a float in (0,1) indicating the proportion of training instances to use for
validation (e.g., 0.3 for using 30% of the training set as validation data), or a LabelledCollection
indicating the validation set itself, or an int indicating the number <cite>k</cite> of folds to be used in <cite>k</cite>-fold
cross validation to estimate the parameters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.ACC.getPteCondEstim">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">getPteCondEstim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ACC.getPteCondEstim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.ACC.solve_adjustment">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solve_adjustment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">PteCondEstim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs_estim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ACC.solve_adjustment" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the system linear system <span class="math notranslate nohighlight">\(Ax = B\)</span> with <span class="math notranslate nohighlight">\(A\)</span> = <cite>PteCondEstim</cite> and <span class="math notranslate nohighlight">\(B\)</span> = <cite>prevs_estim</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>PteCondEstim</strong> – a <cite>np.ndarray</cite> of shape <cite>(n_classes,n_classes,)</cite> with entry <cite>(i,j)</cite> being the estimate
of <span class="math notranslate nohighlight">\(P(y_i|y_j)\)</span>, that is, the probability that an instance that belongs to <span class="math notranslate nohighlight">\(y_j\)</span> ends up being
classified as belonging to <span class="math notranslate nohighlight">\(y_i\)</span></p></li>
<li><p><strong>prevs_estim</strong> – a <cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with the class prevalence estimates</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an adjusted <cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with the corrected class prevalence estimates</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.AdjustedClassifyAndCount">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">AdjustedClassifyAndCount</span></span><a class="headerlink" href="#quapy.method.aggregative.AdjustedClassifyAndCount" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ACC</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeProbabilisticQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">AggregativeProbabilisticQuantifier</span></span><a class="headerlink" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier" title="quapy.method.aggregative.AggregativeQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeQuantifier</span></code></a></p>
<p>Abstract class for quantification methods that base their estimations on the aggregation of posterior probabilities
as returned by a probabilistic classifier. Aggregative Probabilistic Quantifiers thus extend Aggregative
Quantifiers by implementing a _posterior_probabilities_ method returning values in [0,1] – the posterior
probabilities.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeProbabilisticQuantifier.classify">
<span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier.classify" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the label predictions for the given instances. The predictions should respect the format expected by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code>, i.e., posterior probabilities for probabilistic quantifiers, or crisp predictions for
non-probabilistic quantifiers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray of shape <cite>(n_instances,)</cite> with label predictions</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">AggregativeQuantifier</span></span><a class="headerlink" href="#quapy.method.aggregative.AggregativeQuantifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a></p>
<p>Abstract class for quantification methods that base their estimations on the aggregation of classification
results. Aggregative Quantifiers thus implement a <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier.classify" title="quapy.method.aggregative.AggregativeQuantifier.classify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify()</span></code></a> method and maintain a <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier.classifier" title="quapy.method.aggregative.AggregativeQuantifier.classifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">classifier</span></code></a>
attribute. Subclasses of this abstract class must implement the method <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier.aggregate" title="quapy.method.aggregative.AggregativeQuantifier.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a> which computes the
aggregation of label predictions. The method <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier.quantify" title="quapy.method.aggregative.AggregativeQuantifier.quantify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantify()</span></code></a> comes with a default implementation based on
<a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier.classify" title="quapy.method.aggregative.AggregativeQuantifier.classify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify()</span></code></a> and <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier.aggregate" title="quapy.method.aggregative.AggregativeQuantifier.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeQuantifier.aggregate">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_predictions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.AggregativeQuantifier.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeQuantifier.classes_">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quapy.method.aggregative.AggregativeQuantifier.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Class labels, in the same order in which class prevalence values are to be computed.
This default implementation actually returns the class labels of the learner.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeQuantifier.classifier">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">classifier</span></span><a class="headerlink" href="#quapy.method.aggregative.AggregativeQuantifier.classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives access to the classifier</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the classifier (typically an sklearn’s Estimator)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeQuantifier.classify">
<span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.AggregativeQuantifier.classify" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the label predictions for the given instances. The predictions should respect the format expected by
<a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier.aggregate" title="quapy.method.aggregative.AggregativeQuantifier.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a>, i.e., posterior probabilities for probabilistic quantifiers, or crisp predictions for
non-probabilistic quantifiers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray of shape <cite>(n_instances,)</cite> with label predictions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeQuantifier.fit">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.AggregativeQuantifier.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the aggregative quantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p></li>
<li><p><strong>fit_classifier</strong> – whether or not to train the learner (default is True). Set to False if the
learner has been trained outside the quantifier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.AggregativeQuantifier.quantify">
<span class="sig-name descname"><span class="pre">quantify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.AggregativeQuantifier.quantify" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate class prevalence estimates for the sample’s instances by aggregating the label predictions generated
by the classifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.CC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">CC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.CC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier" title="quapy.method.aggregative.AggregativeQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeQuantifier</span></code></a></p>
<p>The most basic Quantification method. One that simply classifies all instances and counts how many have been
attributed to each of the classes in order to compute class prevalence estimates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.CC.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_predictions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.CC.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes class prevalence estimates by counting the prevalence of each of the predicted labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – array-like with label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.CC.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.CC.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the Classify &amp; Count method unless <cite>fit_classifier</cite> is False, in which case, the classifier is assumed to
be already fit and there is nothing else to do.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p></li>
<li><p><strong>fit_classifier</strong> – if False, the classifier is assumed to be fit</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.ClassifyAndCount">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">ClassifyAndCount</span></span><a class="headerlink" href="#quapy.method.aggregative.ClassifyAndCount" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.CC" title="quapy.method.aggregative.CC"><code class="xref py py-class docutils literal notranslate"><span class="pre">CC</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.DistributionMatching">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">DistributionMatching</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divergence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'HD'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.DistributionMatching" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="quapy.method.aggregative.AggregativeProbabilisticQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeProbabilisticQuantifier</span></code></a></p>
<p>Generic Distribution Matching quantifier for binary or multiclass quantification.
This implementation takes the number of bins, the divergence, and the possibility to work on CDF as hyperparameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a <cite>sklearn</cite>’s Estimator that generates a probabilistic classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set to model the
validation distribution.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the validation distribution should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
<li><p><strong>nbins</strong> – number of bins used to discretize the distributions (default 8)</p></li>
<li><p><strong>divergence</strong> – a string representing a divergence measure (currently, “HD” and “topsoe” are implemented)
or a callable function taking two ndarrays of the same dimension as input (default “HD”, meaning Hellinger
Distance)</p></li>
<li><p><strong>cdf</strong> – whether or not to use CDF instead of PDF (default False)</p></li>
<li><p><strong>n_jobs</strong> – number of parallel workers (default None)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.DistributionMatching.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posteriors</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.DistributionMatching.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for the mixture model parameter (the sought prevalence values) that yields a validation distribution
(the mixture) that best matches the test distribution, in terms of the divergence measure of choice.
In the multiclass case, with <cite>n</cite> the number of classes, the test and mixture distributions contain
<cite>n</cite> channels (proper distributions of binned posterior probabilities), on which the divergence is computed
independently. The matching is computed as an average of the divergence across all channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – instances in the sample</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a vector of class prevalence estimates</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.DistributionMatching.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.DistributionMatching.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the classifier (if requested) and generates the validation distributions out of the training data.
The validation distributions have shape <cite>(n, ch, nbins)</cite>, with <cite>n</cite> the number of classes, <cite>ch</cite> the number of
channels, and <cite>nbins</cite> the number of bins. In particular, let <cite>V</cite> be the validation distributions; <cite>di=V[i]</cite>
are the distributions obtained from training data labelled with class <cite>i</cite>; <cite>dij = di[j]</cite> is the discrete
distribution of posterior probabilities <cite>P(Y=j|X=x)</cite> for training data labelled with class <cite>i</cite>, and <cite>dij[k]</cite>
is the fraction of instances with a value in the <cite>k</cite>-th bin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the training set</p></li>
<li><p><strong>fit_classifier</strong> – set to False to bypass the training (the learner is assumed to be already fit)</p></li>
<li><p><strong>val_split</strong> – either a float in (0,1) indicating the proportion of training instances to use for
validation (e.g., 0.3 for using 30% of the training set as validation data), or a LabelledCollection
indicating the validation set itself, or an int indicating the number k of folds to be used in kFCV
to estimate the parameters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.DyS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">DyS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divergence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'HD'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.DyS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="quapy.method.aggregative.AggregativeProbabilisticQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeProbabilisticQuantifier</span></code></a>, <a class="reference internal" href="#quapy.method.base.BinaryQuantifier" title="quapy.method.base.BinaryQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryQuantifier</span></code></a></p>
<p><a class="reference external" href="https://ojs.aaai.org/index.php/AAAI/article/view/4376">DyS framework</a> (DyS).
DyS is a generalization of HDy method, using a Ternary Search in order to find the prevalence that
minimizes the distance between distributions.
Details for the ternary search have been got from &lt;<a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/3219819.3220059">https://dl.acm.org/doi/pdf/10.1145/3219819.3220059</a>&gt;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a binary classifier</p></li>
<li><p><strong>val_split</strong> – a float in range (0,1) indicating the proportion of data to be used as a stratified held-out
validation distribution, or a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
<li><p><strong>n_bins</strong> – an int with the number of bins to use to compute the histograms.</p></li>
<li><p><strong>divergence</strong> – a str indicating the name of divergence (currently supported ones are “HD” or “topsoe”), or a
callable function computes the divergence between two distributions (two equally sized arrays).</p></li>
<li><p><strong>tol</strong> – a float with the tolerance for the ternary search algorithm.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.DyS.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_posteriors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.DyS.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.DyS.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.DyS.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the aggregative quantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p></li>
<li><p><strong>fit_classifier</strong> – whether or not to train the learner (default is True). Set to False if the
learner has been trained outside the quantifier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.EMQ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">EMQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_train_prev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recalib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.EMQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="quapy.method.aggregative.AggregativeProbabilisticQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeProbabilisticQuantifier</span></code></a></p>
<p><a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/6789744">Expectation Maximization for Quantification</a> (EMQ),
aka <cite>Saerens-Latinne-Decaestecker</cite> (SLD) algorithm.
EMQ consists of using the well-known <cite>Expectation Maximization algorithm</cite> to iteratively update the posterior
probabilities generated by a probabilistic classifier and the class prevalence estimates obtained via
maximum-likelihood estimation, in a mutually recursive way, until convergence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>exact_train_prev</strong> – set to True (default) for using, as the initial observation, the true training prevalence;
or set to False for computing the training prevalence as an estimate, akin to PCC, i.e., as the expected
value of the posterior probabilities of the training instances as suggested in
<a class="reference external" href="http://proceedings.mlr.press/v119/alexandari20a.html">Alexandari et al. paper</a>:</p></li>
<li><p><strong>recalib</strong> – a string indicating the method of recalibration. Available choices include “nbvs” (No-Bias Vector
Scaling), “bcts” (Bias-Corrected Temperature Scaling), “ts” (Temperature Scaling), and “vs” (Vector Scaling).
The default value is None, indicating no recalibration.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.EMQ.EM">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posterior_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.EMQ.EM" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the <cite>Expectation Maximization</cite> routine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tr_prev</strong> – array-like, the training prevalence</p></li>
<li><p><strong>posterior_probabilities</strong> – <cite>np.ndarray</cite> of shape <cite>(n_instances, n_classes,)</cite> with the
posterior probabilities</p></li>
<li><p><strong>epsilon</strong> – float, the threshold different between two consecutive iterations
to reach before stopping the loop</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple with the estimated prevalence values (shape <cite>(n_classes,)</cite>) and
the corrected posterior probabilities (shape <cite>(n_instances, n_classes,)</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.EMQ.EPSILON">
<span class="sig-name descname"><span class="pre">EPSILON</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.0001</span></em><a class="headerlink" href="#quapy.method.aggregative.EMQ.EPSILON" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.EMQ.MAX_ITER">
<span class="sig-name descname"><span class="pre">MAX_ITER</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1000</span></em><a class="headerlink" href="#quapy.method.aggregative.EMQ.MAX_ITER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.EMQ.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_posteriors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.EMQ.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.EMQ.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.EMQ.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the aggregative quantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p></li>
<li><p><strong>fit_classifier</strong> – whether or not to train the learner (default is True). Set to False if the
learner has been trained outside the quantifier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.EMQ.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.EMQ.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.ExpectationMaximizationQuantifier">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">ExpectationMaximizationQuantifier</span></span><a class="headerlink" href="#quapy.method.aggregative.ExpectationMaximizationQuantifier" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.EMQ" title="quapy.method.aggregative.EMQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">EMQ</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.HDy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">HDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.HDy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="quapy.method.aggregative.AggregativeProbabilisticQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeProbabilisticQuantifier</span></code></a>, <a class="reference internal" href="#quapy.method.base.BinaryQuantifier" title="quapy.method.base.BinaryQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryQuantifier</span></code></a></p>
<p><a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0020025512004069">Hellinger Distance y</a> (HDy).
HDy is a probabilistic method for training binary quantifiers, that models quantification as the problem of
minimizing the divergence (in terms of the Hellinger Distance) between two cumulative distributions of posterior
probabilities returned by the classifier. One of the distributions is generated from the unlabelled examples and
the other is generated from a validation set. This latter distribution is defined as a mixture of the
class-conditional distributions of the posterior probabilities returned for the positive and negative validation
examples, respectively. The parameters of the mixture thus represent the estimates of the class prevalence values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a binary classifier</p></li>
<li><p><strong>val_split</strong> – a float in range (0,1) indicating the proportion of data to be used as a stratified held-out
validation distribution, or a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.HDy.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_posteriors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.HDy.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.HDy.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.HDy.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a HDy quantifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the training set</p></li>
<li><p><strong>fit_classifier</strong> – set to False to bypass the training (the learner is assumed to be already fit)</p></li>
<li><p><strong>val_split</strong> – either a float in (0,1) indicating the proportion of training instances to use for
validation (e.g., 0.3 for using 30% of the training set as validation data), or a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> indicating the validation set itself</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.HellingerDistanceY">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">HellingerDistanceY</span></span><a class="headerlink" href="#quapy.method.aggregative.HellingerDistanceY" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.HDy" title="quapy.method.aggregative.HDy"><code class="xref py py-class docutils literal notranslate"><span class="pre">HDy</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.MAX">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">MAX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.ThresholdOptimization" title="quapy.method.aggregative.ThresholdOptimization"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThresholdOptimization</span></code></a></p>
<p>Threshold Optimization variant for <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ACC</span></code></a> as proposed by
<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/1150402.1150423">Forman 2006</a> and
<a class="reference external" href="https://link.springer.com/article/10.1007/s10618-008-0097-y">Forman 2008</a> that looks
for the threshold that maximizes <cite>tpr-fpr</cite>.
The goal is to bring improved stability to the denominator of the adjustment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.MS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">MS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.MS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.ThresholdOptimization" title="quapy.method.aggregative.ThresholdOptimization"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThresholdOptimization</span></code></a></p>
<p>Median Sweep. Threshold Optimization variant for <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ACC</span></code></a> as proposed by
<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/1150402.1150423">Forman 2006</a> and
<a class="reference external" href="https://link.springer.com/article/10.1007/s10618-008-0097-y">Forman 2008</a> that generates
class prevalence estimates for all decision thresholds and returns the median of them all.
The goal is to bring improved stability to the denominator of the adjustment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.MS2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">MS2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.MS2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.MS" title="quapy.method.aggregative.MS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MS</span></code></a></p>
<p>Median Sweep 2. Threshold Optimization variant for <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ACC</span></code></a> as proposed by
<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/1150402.1150423">Forman 2006</a> and
<a class="reference external" href="https://link.springer.com/article/10.1007/s10618-008-0097-y">Forman 2008</a> that generates
class prevalence estimates for all decision thresholds and returns the median of for cases in
which <cite>tpr-fpr&gt;0.25</cite>
The goal is to bring improved stability to the denominator of the adjustment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.MedianSweep">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">MedianSweep</span></span><a class="headerlink" href="#quapy.method.aggregative.MedianSweep" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.MS" title="quapy.method.aggregative.MS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MS</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.MedianSweep2">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">MedianSweep2</span></span><a class="headerlink" href="#quapy.method.aggregative.MedianSweep2" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.MS2" title="quapy.method.aggregative.MS2"><code class="xref py py-class docutils literal notranslate"><span class="pre">MS2</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.OneVsAllAggregative">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">OneVsAllAggregative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_quantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel_backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multiprocessing'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.OneVsAllAggregative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.base.OneVsAllGeneric" title="quapy.method.base.OneVsAllGeneric"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneVsAllGeneric</span></code></a>, <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier" title="quapy.method.aggregative.AggregativeQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeQuantifier</span></code></a></p>
<p>Allows any binary quantifier to perform quantification on single-label datasets.
The method maintains one binary quantifier for each class, and then l1-normalizes the outputs so that the
class prevelences sum up to 1.
This variant was used, along with the <a class="reference internal" href="#quapy.method.aggregative.EMQ" title="quapy.method.aggregative.EMQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">EMQ</span></code></a> quantifier, in
<a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s13278-016-0327-z.pdf">Gao and Sebastiani, 2016</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>binary_quantifier</strong> – a quantifier (binary) that will be employed to work on multiclass model in a
one-vs-all manner</p></li>
<li><p><strong>n_jobs</strong> – number of parallel workers</p></li>
<li><p><strong>parallel_backend</strong> – the parallel backend for joblib (default “loky”); this is helpful for some quantifiers
(e.g., ELM-based ones) that cannot be run with multiprocessing, since the temp dir they create during fit will
is removed and no longer available at predict time.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.OneVsAllAggregative.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_predictions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.OneVsAllAggregative.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.OneVsAllAggregative.classify">
<span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.OneVsAllAggregative.classify" title="Permalink to this definition">¶</a></dt>
<dd><p>If the base quantifier is not probabilistic, returns a matrix of shape <cite>(n,m,)</cite> with <cite>n</cite> the number of
instances and <cite>m</cite> the number of classes. The entry <cite>(i,j)</cite> is a binary value indicating whether instance
<cite>i `belongs to class `j</cite>. The binary classifications are independent of each other, meaning that an instance
can end up be attributed to 0, 1, or more classes.
If the base quantifier is probabilistic, returns a matrix of shape <cite>(n,m,2)</cite> with <cite>n</cite> the number of instances
and <cite>m</cite> the number of classes. The entry <cite>(i,j,1)</cite> (resp. <cite>(i,j,0)</cite>) is a value in [0,1] indicating the
posterior probability that instance <cite>i</cite> belongs (resp. does not belong) to class <cite>j</cite>. The posterior
probabilities are independent of each other, meaning that, in general, they do not sum up to one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.PACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">PACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PACC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="quapy.method.aggregative.AggregativeProbabilisticQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeProbabilisticQuantifier</span></code></a></p>
<p><a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/5694031">Probabilistic Adjusted Classify &amp; Count</a>,
the probabilistic variant of ACC that relies on the posterior probabilities returned by a probabilistic classifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
<li><p><strong>n_jobs</strong> – number of parallel workers</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.PACC.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_posteriors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PACC.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.PACC.classify">
<span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PACC.classify" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the label predictions for the given instances. The predictions should respect the format expected by
<a class="reference internal" href="#quapy.method.aggregative.PACC.aggregate" title="quapy.method.aggregative.PACC.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a>, i.e., posterior probabilities for probabilistic quantifiers, or crisp predictions for
non-probabilistic quantifiers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray of shape <cite>(n_instances,)</cite> with label predictions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.PACC.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PACC.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a PACC quantifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the training set</p></li>
<li><p><strong>fit_classifier</strong> – set to False to bypass the training (the learner is assumed to be already fit)</p></li>
<li><p><strong>val_split</strong> – either a float in (0,1) indicating the proportion of training instances to use for
validation (e.g., 0.3 for using 30% of the training set as validation data), or a LabelledCollection
indicating the validation set itself, or an int indicating the number k of folds to be used in kFCV
to estimate the parameters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.PACC.getPteCondEstim">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">getPteCondEstim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PACC.getPteCondEstim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.PCC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">PCC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="quapy.method.aggregative.AggregativeProbabilisticQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeProbabilisticQuantifier</span></code></a></p>
<p><a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/5694031">Probabilistic Classify &amp; Count</a>,
the probabilistic variant of CC that relies on the posterior probabilities returned by a probabilistic classifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.PCC.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_posteriors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PCC.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.PCC.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.PCC.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the aggregative quantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p></li>
<li><p><strong>fit_classifier</strong> – whether or not to train the learner (default is True). Set to False if the
learner has been trained outside the quantifier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.ProbabilisticAdjustedClassifyAndCount">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">ProbabilisticAdjustedClassifyAndCount</span></span><a class="headerlink" href="#quapy.method.aggregative.ProbabilisticAdjustedClassifyAndCount" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.PACC" title="quapy.method.aggregative.PACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">PACC</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.ProbabilisticClassifyAndCount">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">ProbabilisticClassifyAndCount</span></span><a class="headerlink" href="#quapy.method.aggregative.ProbabilisticClassifyAndCount" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.PCC" title="quapy.method.aggregative.PCC"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCC</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.aggregative.SLD">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">SLD</span></span><a class="headerlink" href="#quapy.method.aggregative.SLD" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#quapy.method.aggregative.EMQ" title="quapy.method.aggregative.EMQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">EMQ</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.SMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">SMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.SMM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeProbabilisticQuantifier" title="quapy.method.aggregative.AggregativeProbabilisticQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeProbabilisticQuantifier</span></code></a>, <a class="reference internal" href="#quapy.method.base.BinaryQuantifier" title="quapy.method.base.BinaryQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryQuantifier</span></code></a></p>
<p><a class="reference external" href="https://ieeexplore.ieee.org/document/9260028">SMM method</a> (SMM).
SMM is a simplification of matching distribution methods where the representation of the examples
is created using the mean instead of a histogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a binary classifier.</p></li>
<li><p><strong>val_split</strong> – a float in range (0,1) indicating the proportion of data to be used as a stratified held-out
validation distribution, or a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.SMM.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_posteriors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.SMM.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.SMM.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.SMM.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the aggregative quantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p></li>
<li><p><strong>fit_classifier</strong> – whether or not to train the learner (default is True). Set to False if the
learner has been trained outside the quantifier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.T50">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">T50</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.T50" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.ThresholdOptimization" title="quapy.method.aggregative.ThresholdOptimization"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThresholdOptimization</span></code></a></p>
<p>Threshold Optimization variant for <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ACC</span></code></a> as proposed by
<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/1150402.1150423">Forman 2006</a> and
<a class="reference external" href="https://link.springer.com/article/10.1007/s10618-008-0097-y">Forman 2008</a> that looks
for the threshold that makes <cite>tpr</cite> cosest to 0.5.
The goal is to bring improved stability to the denominator of the adjustment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.ThresholdOptimization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">ThresholdOptimization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ThresholdOptimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.AggregativeQuantifier" title="quapy.method.aggregative.AggregativeQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregativeQuantifier</span></code></a>, <a class="reference internal" href="#quapy.method.base.BinaryQuantifier" title="quapy.method.base.BinaryQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryQuantifier</span></code></a></p>
<p>Abstract class of Threshold Optimization variants for <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ACC</span></code></a> as proposed by
<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/1150402.1150423">Forman 2006</a> and
<a class="reference external" href="https://link.springer.com/article/10.1007/s10618-008-0097-y">Forman 2008</a>.
The goal is to bring improved stability to the denominator of the adjustment.
The different variants are based on different heuristics for choosing a decision threshold
that would allow for more true positives and many more false positives, on the grounds this
would deliver larger denominators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.ThresholdOptimization.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classif_predictions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ThresholdOptimization.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the aggregation of label predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>classif_predictions</strong> – <cite>np.ndarray</cite> of label predictions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.aggregative.ThresholdOptimization.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.ThresholdOptimization.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the aggregative quantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p></li>
<li><p><strong>fit_classifier</strong> – whether or not to train the learner (default is True). Set to False if the
learner has been trained outside the quantifier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.aggregative.X">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.X" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.aggregative.ThresholdOptimization" title="quapy.method.aggregative.ThresholdOptimization"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThresholdOptimization</span></code></a></p>
<p>Threshold Optimization variant for <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ACC</span></code></a> as proposed by
<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/1150402.1150423">Forman 2006</a> and
<a class="reference external" href="https://link.springer.com/article/10.1007/s10618-008-0097-y">Forman 2008</a> that looks
for the threshold that yields <cite>tpr=1-fpr</cite>.
The goal is to bring improved stability to the denominator of the adjustment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – a sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>val_split</strong> – indicates the proportion of data to be used as a stratified held-out validation set in which the
misclassification rates are to be estimated.
This parameter can be indicated as a real value (between 0 and 1, default 0.4), representing a proportion of
validation data, or as an integer, indicating that the misclassification rates should be estimated via
<cite>k</cite>-fold cross validation (this integer stands for the number of folds <cite>k</cite>), or as a
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.aggregative.cross_generate_predictions">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">cross_generate_predictions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probabilistic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.cross_generate_predictions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.aggregative.newELM">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">newELM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">svmperf_base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'01'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.newELM" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicit Loss Minimization (ELM) quantifiers.
Quantifiers based on ELM represent a family of methods based on structured output learning;
these quantifiers rely on classifiers that have been optimized using a quantification-oriented loss
measure. This implementation relies on
<a class="reference external" href="https://www.cs.cornell.edu/people/tj/svm_light/svm_perf.html">Joachims’ SVM perf</a> structured output
learning algorithm, which has to be installed and patched for the purpose (see this
<a class="reference external" href="https://github.com/HLT-ISTI/QuaPy/blob/master/prepare_svmperf.sh">script</a>).
This function equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CC</span><span class="p">(</span><span class="n">SVMperf</span><span class="p">(</span><span class="n">svmperf_base</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>svmperf_base</strong> – path to the folder containing the binary files of <cite>SVM perf</cite>; if set to None (default)
this path will be obtained from qp.environ[‘SVMPERF_HOME’]</p></li>
<li><p><strong>loss</strong> – the loss to optimize (see <a class="reference internal" href="quapy.classification.html#quapy.classification.svmperf.SVMperf.valid_losses" title="quapy.classification.svmperf.SVMperf.valid_losses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">quapy.classification.svmperf.SVMperf.valid_losses</span></code></a>)</p></li>
<li><p><strong>C</strong> – trade-off between training error and margin (default 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns an instance of CC set to work with SVMperf (with loss and C set properly) as the
underlying classifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.aggregative.newSVMAE">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">newSVMAE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">svmperf_base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.newSVMAE" title="Permalink to this definition">¶</a></dt>
<dd><p>SVM(KLD) is an Explicit Loss Minimization (ELM) quantifier set to optimize for the Absolute Error as first used by
<a class="reference external" href="https://arxiv.org/abs/2011.02552">Moreo and Sebastiani, 2021</a>.
Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CC</span><span class="p">(</span><span class="n">SVMperf</span><span class="p">(</span><span class="n">svmperf_base</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mae&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
<p>Quantifiers based on ELM represent a family of methods based on structured output learning;
these quantifiers rely on classifiers that have been optimized using a quantification-oriented loss
measure. This implementation relies on
<a class="reference external" href="https://www.cs.cornell.edu/people/tj/svm_light/svm_perf.html">Joachims’ SVM perf</a> structured output
learning algorithm, which has to be installed and patched for the purpose (see this
<a class="reference external" href="https://github.com/HLT-ISTI/QuaPy/blob/master/prepare_svmperf.sh">script</a>).
This function is a wrapper around CC(SVMperf(svmperf_base, loss, C))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>svmperf_base</strong> – path to the folder containing the binary files of <cite>SVM perf</cite>; if set to None (default)
this path will be obtained from qp.environ[‘SVMPERF_HOME’]</p></li>
<li><p><strong>C</strong> – trade-off between training error and margin (default 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns an instance of CC set to work with SVMperf (with loss and C set properly) as the
underlying classifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.aggregative.newSVMKLD">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">newSVMKLD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">svmperf_base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.newSVMKLD" title="Permalink to this definition">¶</a></dt>
<dd><p>SVM(KLD) is an Explicit Loss Minimization (ELM) quantifier set to optimize for the Kullback-Leibler Divergence
normalized via the logistic function, as proposed by
<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/2700406">Esuli et al. 2015</a>.
Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CC</span><span class="p">(</span><span class="n">SVMperf</span><span class="p">(</span><span class="n">svmperf_base</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;nkld&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
<p>Quantifiers based on ELM represent a family of methods based on structured output learning;
these quantifiers rely on classifiers that have been optimized using a quantification-oriented loss
measure. This implementation relies on
<a class="reference external" href="https://www.cs.cornell.edu/people/tj/svm_light/svm_perf.html">Joachims’ SVM perf</a> structured output
learning algorithm, which has to be installed and patched for the purpose (see this
<a class="reference external" href="https://github.com/HLT-ISTI/QuaPy/blob/master/prepare_svmperf.sh">script</a>).
This function is a wrapper around CC(SVMperf(svmperf_base, loss, C))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>svmperf_base</strong> – path to the folder containing the binary files of <cite>SVM perf</cite>; if set to None (default)
this path will be obtained from qp.environ[‘SVMPERF_HOME’]</p></li>
<li><p><strong>C</strong> – trade-off between training error and margin (default 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns an instance of CC set to work with SVMperf (with loss and C set properly) as the
underlying classifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.aggregative.newSVMQ">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">newSVMQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">svmperf_base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.newSVMQ" title="Permalink to this definition">¶</a></dt>
<dd><p>SVM(Q) is an Explicit Loss Minimization (ELM) quantifier set to optimize for the <cite>Q</cite> loss combining a
classification-oriented loss and a quantification-oriented loss, as proposed by
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S003132031400291X">Barranquero et al. 2015</a>.
Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CC</span><span class="p">(</span><span class="n">SVMperf</span><span class="p">(</span><span class="n">svmperf_base</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
<p>Quantifiers based on ELM represent a family of methods based on structured output learning;
these quantifiers rely on classifiers that have been optimized using a quantification-oriented loss
measure. This implementation relies on
<a class="reference external" href="https://www.cs.cornell.edu/people/tj/svm_light/svm_perf.html">Joachims’ SVM perf</a> structured output
learning algorithm, which has to be installed and patched for the purpose (see this
<a class="reference external" href="https://github.com/HLT-ISTI/QuaPy/blob/master/prepare_svmperf.sh">script</a>).
This function is a wrapper around CC(SVMperf(svmperf_base, loss, C))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>svmperf_base</strong> – path to the folder containing the binary files of <cite>SVM perf</cite>; if set to None (default)
this path will be obtained from qp.environ[‘SVMPERF_HOME’]</p></li>
<li><p><strong>C</strong> – trade-off between training error and margin (default 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns an instance of CC set to work with SVMperf (with loss and C set properly) as the
underlying classifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.aggregative.newSVMRAE">
<span class="sig-prename descclassname"><span class="pre">quapy.method.aggregative.</span></span><span class="sig-name descname"><span class="pre">newSVMRAE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">svmperf_base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.aggregative.newSVMRAE" title="Permalink to this definition">¶</a></dt>
<dd><p>SVM(KLD) is an Explicit Loss Minimization (ELM) quantifier set to optimize for the Relative Absolute Error as first
used by <a class="reference external" href="https://arxiv.org/abs/2011.02552">Moreo and Sebastiani, 2021</a>.
Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CC</span><span class="p">(</span><span class="n">SVMperf</span><span class="p">(</span><span class="n">svmperf_base</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mrae&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
<p>Quantifiers based on ELM represent a family of methods based on structured output learning;
these quantifiers rely on classifiers that have been optimized using a quantification-oriented loss
measure. This implementation relies on
<a class="reference external" href="https://www.cs.cornell.edu/people/tj/svm_light/svm_perf.html">Joachims’ SVM perf</a> structured output
learning algorithm, which has to be installed and patched for the purpose (see this
<a class="reference external" href="https://github.com/HLT-ISTI/QuaPy/blob/master/prepare_svmperf.sh">script</a>).
This function is a wrapper around CC(SVMperf(svmperf_base, loss, C))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>svmperf_base</strong> – path to the folder containing the binary files of <cite>SVM perf</cite>; if set to None (default)
this path will be obtained from qp.environ[‘SVMPERF_HOME’]</p></li>
<li><p><strong>C</strong> – trade-off between training error and margin (default 0.01)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns an instance of CC set to work with SVMperf (with loss and C set properly) as the
underlying classifier</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.method.base">
<span id="quapy-method-base"></span><h2>quapy.method.base<a class="headerlink" href="#module-quapy.method.base" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.base.BaseQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.base.</span></span><span class="sig-name descname"><span class="pre">BaseQuantifier</span></span><a class="headerlink" href="#quapy.method.base.BaseQuantifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Abstract Quantifier. A quantifier is defined as an object of a class that implements the method <a class="reference internal" href="#quapy.method.base.BaseQuantifier.fit" title="quapy.method.base.BaseQuantifier.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> on
<a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a>, the method <a class="reference internal" href="#quapy.method.base.BaseQuantifier.quantify" title="quapy.method.base.BaseQuantifier.quantify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantify()</span></code></a>, and the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_params()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_params()</span></code> for model selection (see <a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ()</span></code></a>)</p>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.base.BaseQuantifier.fit">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.base.BaseQuantifier.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a quantifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.base.BaseQuantifier.quantify">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">quantify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.base.BaseQuantifier.quantify" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate class prevalence estimates for the sample’s instances</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.base.BinaryQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.base.</span></span><span class="sig-name descname"><span class="pre">BinaryQuantifier</span></span><a class="headerlink" href="#quapy.method.base.BinaryQuantifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a></p>
<p>Abstract class of binary quantifiers, i.e., quantifiers estimating class prevalence values for only two classes
(typically, to be interpreted as one class and its complement).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.base.OneVsAll">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.base.</span></span><span class="sig-name descname"><span class="pre">OneVsAll</span></span><a class="headerlink" href="#quapy.method.base.OneVsAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.base.OneVsAllGeneric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.base.</span></span><span class="sig-name descname"><span class="pre">OneVsAllGeneric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_quantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.base.OneVsAllGeneric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.base.OneVsAll" title="quapy.method.base.OneVsAll"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneVsAll</span></code></a>, <a class="reference internal" href="#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a></p>
<p>Allows any binary quantifier to perform quantification on single-label datasets. The method maintains one binary
quantifier for each class, and then l1-normalizes the outputs so that the class prevelence values sum up to 1.</p>
<dl class="py property">
<dt class="sig sig-object py" id="quapy.method.base.OneVsAllGeneric.classes_">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quapy.method.base.OneVsAllGeneric.classes_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.base.OneVsAllGeneric.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.base.OneVsAllGeneric.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a quantifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.base.OneVsAllGeneric.quantify">
<span class="sig-name descname"><span class="pre">quantify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.base.OneVsAllGeneric.quantify" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate class prevalence estimates for the sample’s instances</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.base.newOneVsAll">
<span class="sig-prename descclassname"><span class="pre">quapy.method.base.</span></span><span class="sig-name descname"><span class="pre">newOneVsAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_quantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.base.newOneVsAll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-quapy.method.meta">
<span id="quapy-method-meta"></span><h2>quapy.method.meta<a class="headerlink" href="#module-quapy.method.meta" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.meta.EACC">
<span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">EACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_mod_sel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.EACC" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an ensemble of <a class="reference internal" href="#quapy.method.aggregative.ACC" title="quapy.method.aggregative.ACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.aggregative.ACC</span></code></a> quantifiers, as used by
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1566253517303652">Pérez-Gállego et al., 2019</a>.</p>
<p>Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensembleFactory</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">ACC</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">optim</span><span class="p">,</span> <span class="n">param_mod_sel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#quapy.method.meta.ensembleFactory" title="quapy.method.meta.ensembleFactory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensembleFactory()</span></code></a> for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>param_grid</strong> – a dictionary with the grid of parameters to optimize for</p></li>
<li><p><strong>optim</strong> – a valid quantification or classification error, or a string name of it</p></li>
<li><p><strong>param_model_sel</strong> – a dictionary containing any keyworded argument to pass to
<a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a></p></li>
<li><p><strong>kwargs</strong> – kwargs for the class <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.meta.ECC">
<span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">ECC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_mod_sel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.ECC" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an ensemble of <a class="reference internal" href="#quapy.method.aggregative.CC" title="quapy.method.aggregative.CC"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.aggregative.CC</span></code></a> quantifiers, as used by
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1566253517303652">Pérez-Gállego et al., 2019</a>.</p>
<p>Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensembleFactory</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">CC</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">optim</span><span class="p">,</span> <span class="n">param_mod_sel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#quapy.method.meta.ensembleFactory" title="quapy.method.meta.ensembleFactory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensembleFactory()</span></code></a> for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>param_grid</strong> – a dictionary with the grid of parameters to optimize for</p></li>
<li><p><strong>optim</strong> – a valid quantification or classification error, or a string name of it</p></li>
<li><p><strong>param_model_sel</strong> – a dictionary containing any keyworded argument to pass to
<a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a></p></li>
<li><p><strong>kwargs</strong> – kwargs for the class <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.meta.EEMQ">
<span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">EEMQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_mod_sel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.EEMQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an ensemble of <a class="reference internal" href="#quapy.method.aggregative.EMQ" title="quapy.method.aggregative.EMQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.aggregative.EMQ</span></code></a> quantifiers.</p>
<p>Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensembleFactory</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">EMQ</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">optim</span><span class="p">,</span> <span class="n">param_mod_sel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#quapy.method.meta.ensembleFactory" title="quapy.method.meta.ensembleFactory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensembleFactory()</span></code></a> for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>param_grid</strong> – a dictionary with the grid of parameters to optimize for</p></li>
<li><p><strong>optim</strong> – a valid quantification or classification error, or a string name of it</p></li>
<li><p><strong>param_model_sel</strong> – a dictionary containing any keyworded argument to pass to
<a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a></p></li>
<li><p><strong>kwargs</strong> – kwargs for the class <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.meta.EHDy">
<span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">EHDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_mod_sel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.EHDy" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an ensemble of <a class="reference internal" href="#quapy.method.aggregative.HDy" title="quapy.method.aggregative.HDy"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.aggregative.HDy</span></code></a> quantifiers, as used by
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1566253517303652">Pérez-Gállego et al., 2019</a>.</p>
<p>Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensembleFactory</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">HDy</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">optim</span><span class="p">,</span> <span class="n">param_mod_sel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#quapy.method.meta.ensembleFactory" title="quapy.method.meta.ensembleFactory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensembleFactory()</span></code></a> for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>param_grid</strong> – a dictionary with the grid of parameters to optimize for</p></li>
<li><p><strong>optim</strong> – a valid quantification or classification error, or a string name of it</p></li>
<li><p><strong>param_model_sel</strong> – a dictionary containing any keyworded argument to pass to
<a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a></p></li>
<li><p><strong>kwargs</strong> – kwargs for the class <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.meta.EPACC">
<span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">EPACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_mod_sel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.EPACC" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an ensemble of <a class="reference internal" href="#quapy.method.aggregative.PACC" title="quapy.method.aggregative.PACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.aggregative.PACC</span></code></a> quantifiers.</p>
<p>Equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensembleFactory</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">PACC</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">optim</span><span class="p">,</span> <span class="n">param_mod_sel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#quapy.method.meta.ensembleFactory" title="quapy.method.meta.ensembleFactory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensembleFactory()</span></code></a> for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>param_grid</strong> – a dictionary with the grid of parameters to optimize for</p></li>
<li><p><strong>optim</strong> – a valid quantification or classification error, or a string name of it</p></li>
<li><p><strong>param_model_sel</strong> – a dictionary containing any keyworded argument to pass to
<a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a></p></li>
<li><p><strong>kwargs</strong> – kwargs for the class <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">Ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><span class="pre">BaseQuantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">red_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ave'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sample_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble.VALID_POLICIES">
<span class="sig-name descname"><span class="pre">VALID_POLICIES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'ave',</span> <span class="pre">'ds',</span> <span class="pre">'mae',</span> <span class="pre">'mkld',</span> <span class="pre">'mnkld',</span> <span class="pre">'mrae',</span> <span class="pre">'mse',</span> <span class="pre">'ptr'}</span></em><a class="headerlink" href="#quapy.method.meta.Ensemble.VALID_POLICIES" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the Ensemble methods for quantification described by
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1566253516300628">Pérez-Gállego et al., 2017</a>
and
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1566253517303652">Pérez-Gállego et al., 2019</a>.
The policies implemented include:</p>
<ul class="simple">
<li><p>Average (<cite>policy=’ave’</cite>): computes class prevalence estimates as the average of the estimates
returned by the base quantifiers.</p></li>
<li><p>Training Prevalence (<cite>policy=’ptr’</cite>): applies a dynamic selection to the ensemble’s members by retaining only
those members such that the class prevalence values in the samples they use as training set are closest to
preliminary class prevalence estimates computed as the average of the estimates of all the members. The final
estimate is recomputed by considering only the selected members.</p></li>
<li><p>Distribution Similarity (<cite>policy=’ds’</cite>): performs a dynamic selection of base members by retaining
the members trained on samples whose distribution of posterior probabilities is closest, in terms of the
Hellinger Distance, to the distribution of posterior probabilities in the test sample</p></li>
<li><p>Accuracy (<cite>policy=’&lt;valid error name&gt;’</cite>): performs a static selection of the ensemble members by
retaining those that minimize a quantification error measure, which is passed as an argument.</p></li>
</ul>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">Ensemble</span><span class="p">(</span><span class="n">quantifier</span><span class="o">=</span><span class="n">ACC</span><span class="p">(</span><span class="n">LogisticRegression</span><span class="p">()),</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="s1">&#39;ave&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantifier</strong> – base quantification member of the ensemble</p></li>
<li><p><strong>size</strong> – number of members</p></li>
<li><p><strong>red_size</strong> – number of members to retain after selection (depending on the policy)</p></li>
<li><p><strong>min_pos</strong> – minimum number of positive instances to consider a sample as valid</p></li>
<li><p><strong>policy</strong> – the selection policy; available policies include: <cite>ave</cite> (default), <cite>ptr</cite>, <cite>ds</cite>, and accuracy
(which is instantiated via a valid error name, e.g., <cite>mae</cite>)</p></li>
<li><p><strong>max_sample_size</strong> – maximum number of instances to consider in the samples (set to None
to indicate no limit, default)</p></li>
<li><p><strong>val_split</strong> – a float in range (0,1) indicating the proportion of data to be used as a stratified held-out
validation split, or a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> (the split itself).</p></li>
<li><p><strong>n_jobs</strong> – number of parallel workers (default 1)</p></li>
<li><p><strong>verbose</strong> – set to True (default is False) to get some information in standard output</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble.aggregative">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aggregative</span></span><a class="headerlink" href="#quapy.method.meta.Ensemble.aggregative" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that the quantifier is not aggregative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>False</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.Ensemble.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a quantifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – a <a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.data.base.LabelledCollection</span></code></a> consisting of the training data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble.get_params">
<span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.Ensemble.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should not be used within <a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a> (is here for compatibility
with the abstract class).
Instead, use <cite>Ensemble(GridSearchQ(q),…)</cite>, with <cite>q</cite> a Quantifier (recommended), or
<cite>Ensemble(Q(GridSearchCV(l)))</cite> with <cite>Q</cite> a quantifier class that has a classifier <cite>l</cite> optimized for
classification (not recommended).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>deep</strong> – for compatibility with scikit-learn</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>raises an Exception</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble.probabilistic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">probabilistic</span></span><a class="headerlink" href="#quapy.method.meta.Ensemble.probabilistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that the quantifier is not probabilistic.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>False</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble.quantify">
<span class="sig-name descname"><span class="pre">quantify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.Ensemble.quantify" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate class prevalence estimates for the sample’s instances</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.meta.Ensemble.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.Ensemble.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should not be used within <a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a> (is here for compatibility
with the abstract class).
Instead, use <cite>Ensemble(GridSearchQ(q),…)</cite>, with <cite>q</cite> a Quantifier (recommended), or
<cite>Ensemble(Q(GridSearchCV(l)))</cite> with <cite>Q</cite> a quantifier class that has a classifier <cite>l</cite> optimized for
classification (not recommended).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>parameters</strong> – dictionary</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>raises an Exception</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.meta.ensembleFactory">
<span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">ensembleFactory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_quantifier_class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_model_sel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">dict</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.ensembleFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensemble factory. Provides a unified interface for instantiating ensembles that can be optimized (via model
selection for quantification) for a given evaluation metric using <a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a>.
If the evaluation metric is classification-oriented
(instead of quantification-oriented), then the optimization will be carried out via sklearn’s
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html">GridSearchCV</a>.</p>
<p>Example to instantiate an <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a> based on <a class="reference internal" href="#quapy.method.aggregative.PACC" title="quapy.method.aggregative.PACC"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.method.aggregative.PACC</span></code></a>
in which the base members are optimized for <a class="reference internal" href="quapy.html#quapy.error.mae" title="quapy.error.mae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.mae()</span></code></a> via
<a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a>. The ensemble follows the policy <cite>Accuracy</cite> based
on <a class="reference internal" href="quapy.html#quapy.error.mae" title="quapy.error.mae"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quapy.error.mae()</span></code></a> (the same measure being optimized),
meaning that a static selection of members of the ensemble is made based on their performance
in terms of this error.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;class_weight&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_mod_sel</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;sample_size&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;protocol&#39;</span><span class="p">:</span> <span class="s1">&#39;app&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common</span><span class="o">=</span><span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_sample_size&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;param_grid&#39;</span><span class="p">:</span> <span class="n">param_grid</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;param_mod_sel&#39;</span><span class="p">:</span> <span class="n">param_mod_sel</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensembleFactory</span><span class="p">(</span><span class="n">LogisticRegression</span><span class="p">(),</span> <span class="n">PACC</span><span class="p">,</span> <span class="n">optim</span><span class="o">=</span><span class="s1">&#39;mae&#39;</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="s1">&#39;mae&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">common</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – sklearn’s Estimator that generates a classifier</p></li>
<li><p><strong>base_quantifier_class</strong> – a class of quantifiers</p></li>
<li><p><strong>param_grid</strong> – a dictionary with the grid of parameters to optimize for</p></li>
<li><p><strong>optim</strong> – a valid quantification or classification error, or a string name of it</p></li>
<li><p><strong>param_model_sel</strong> – a dictionary containing any keyworded argument to pass to
<a class="reference internal" href="quapy.html#quapy.model_selection.GridSearchQ" title="quapy.model_selection.GridSearchQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">quapy.model_selection.GridSearchQ</span></code></a></p></li>
<li><p><strong>kwargs</strong> – kwargs for the class <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an instance of <a class="reference internal" href="#quapy.method.meta.Ensemble" title="quapy.method.meta.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.meta.get_probability_distribution">
<span class="sig-prename descclassname"><span class="pre">quapy.method.meta.</span></span><span class="sig-name descname"><span class="pre">get_probability_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.meta.get_probability_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a histogram out of the posterior probabilities (only for the binary case).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>posterior_probabilities</strong> – array-like of shape <cite>(n_instances, 2,)</cite></p></li>
<li><p><strong>bins</strong> – integer</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> with the relative frequencies for each bin (for the positive class only)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.method.neural">
<span id="quapy-method-neural"></span><h2>quapy.method.neural<a class="headerlink" href="#module-quapy.method.neural" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetModule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.neural.</span></span><span class="sig-name descname"><span class="pre">QuaNetModule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">doc_embedding_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lstm_hidden_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lstm_nlayers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ff_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1024,</span> <span class="pre">512]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bidirectional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdrop_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_by</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Implements the <a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3269206.3269287">QuaNet</a> forward pass.
See <a class="reference internal" href="#quapy.method.neural.QuaNetTrainer" title="quapy.method.neural.QuaNetTrainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuaNetTrainer</span></code></a> for training QuaNet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>doc_embedding_size</strong> – integer, the dimensionality of the document embeddings</p></li>
<li><p><strong>n_classes</strong> – integer, number of classes</p></li>
<li><p><strong>stats_size</strong> – integer, number of statistics estimated by simple quantification methods</p></li>
<li><p><strong>lstm_hidden_size</strong> – integer, hidden dimensionality of the LSTM cell</p></li>
<li><p><strong>lstm_nlayers</strong> – integer, number of LSTM layers</p></li>
<li><p><strong>ff_layers</strong> – list of integers, dimensions of the densely-connected FF layers on top of the
quantification embedding</p></li>
<li><p><strong>bidirectional</strong> – boolean, whether or not to use bidirectional LSTM</p></li>
<li><p><strong>qdrop_p</strong> – float, dropout probability</p></li>
<li><p><strong>order_by</strong> – integer, class for which the document embeddings are to be sorted</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetModule.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#quapy.method.neural.QuaNetModule.device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetModule.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">doc_embeddings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc_posteriors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">statistics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetModule.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetModule.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#quapy.method.neural.QuaNetModule.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.neural.</span></span><span class="sig-name descname"><span class="pre">QuaNetTrainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_iter_per_poch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">va_iter_per_poch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lstm_hidden_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lstm_nlayers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ff_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1024,</span> <span class="pre">512]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bidirectional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdrop_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patience</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpointdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'../checkpoint'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpointname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cuda'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a></p>
<p>Implementation of <a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3269206.3269287">QuaNet</a>, a neural network for
quantification. This implementation uses <a class="reference external" href="https://pytorch.org/">PyTorch</a> and can take advantage of GPU
for speeding-up the training phase.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">quapy</span> <span class="k">as</span> <span class="nn">qp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">quapy.method.meta</span> <span class="kn">import</span> <span class="n">QuaNet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">quapy.classification.neural</span> <span class="kn">import</span> <span class="n">NeuralClassifierTrainer</span><span class="p">,</span> <span class="n">CNNnet</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># use samples of 100 elements</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;SAMPLE_SIZE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># load the kindle dataset as text, and convert words to numerical indexes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">qp</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">fetch_reviews</span><span class="p">(</span><span class="s1">&#39;kindle&#39;</span><span class="p">,</span> <span class="n">pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">min_df</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the text classifier is a CNN trained by NeuralClassifierTrainer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnn</span> <span class="o">=</span> <span class="n">CNNnet</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">vocabulary_size</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">n_classes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classifier</span> <span class="o">=</span> <span class="n">NeuralClassifierTrainer</span><span class="p">(</span><span class="n">cnn</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># train QuaNet (QuaNet is an alias to QuaNetTrainer)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">QuaNet</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">qp</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;SAMPLE_SIZE&#39;</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estim_prevalence</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">quantify</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">test</span><span class="o">.</span><span class="n">instances</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – an object implementing <cite>fit</cite> (i.e., that can be trained on labelled data),
<cite>predict_proba</cite> (i.e., that can generate posterior probabilities of unlabelled examples) and
<cite>transform</cite> (i.e., that can generate embedded representations of the unlabelled instances).</p></li>
<li><p><strong>sample_size</strong> – integer, the sample size; default is None, meaning that the sample size should be
taken from qp.environ[“SAMPLE_SIZE”]</p></li>
<li><p><strong>n_epochs</strong> – integer, maximum number of training epochs</p></li>
<li><p><strong>tr_iter_per_poch</strong> – integer, number of training iterations before considering an epoch complete</p></li>
<li><p><strong>va_iter_per_poch</strong> – integer, number of validation iterations to perform after each epoch</p></li>
<li><p><strong>lr</strong> – float, the learning rate</p></li>
<li><p><strong>lstm_hidden_size</strong> – integer, hidden dimensionality of the LSTM cells</p></li>
<li><p><strong>lstm_nlayers</strong> – integer, number of LSTM layers</p></li>
<li><p><strong>ff_layers</strong> – list of integers, dimensions of the densely-connected FF layers on top of the
quantification embedding</p></li>
<li><p><strong>bidirectional</strong> – boolean, indicates whether the LSTM is bidirectional or not</p></li>
<li><p><strong>qdrop_p</strong> – float, dropout probability</p></li>
<li><p><strong>patience</strong> – integer, number of epochs showing no improvement in the validation set before stopping the
training phase (early stopping)</p></li>
<li><p><strong>checkpointdir</strong> – string, a path where to store models’ checkpoints</p></li>
<li><p><strong>checkpointname</strong> – string (optional), the name of the model’s checkpoint</p></li>
<li><p><strong>device</strong> – string, indicate “cpu” or “cuda”</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer.classes_">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer.classes_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer.clean_checkpoint">
<span class="sig-name descname"><span class="pre">clean_checkpoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer.clean_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the checkpoint</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer.clean_checkpoint_dir">
<span class="sig-name descname"><span class="pre">clean_checkpoint_dir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer.clean_checkpoint_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes anything contained in the checkpoint directory</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains QuaNet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the training data on which to train QuaNet. If <cite>fit_classifier=True</cite>, the data will be split in
40/40/20 for training the classifier, training QuaNet, and validating QuaNet, respectively. If
<cite>fit_classifier=False</cite>, the data will be split in 66/34 for training QuaNet and validating it, respectively.</p></li>
<li><p><strong>fit_classifier</strong> – if True, trains the classifier on a split containing 40% of the data</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer.get_params">
<span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>deep</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>params</strong> – Parameter names mapped to their values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer.quantify">
<span class="sig-name descname"><span class="pre">quantify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer.quantify" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate class prevalence estimates for the sample’s instances</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>np.ndarray</cite> of shape <cite>(n_classes,)</cite> with class prevalence estimates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.neural.QuaNetTrainer.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.QuaNetTrainer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**params</strong> (<em>dict</em>) – Estimator parameters.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Estimator instance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator instance</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quapy.method.neural.mae_loss">
<span class="sig-prename descclassname"><span class="pre">quapy.method.neural.</span></span><span class="sig-name descname"><span class="pre">mae_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.neural.mae_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Torch-like wrapper for the Mean Absolute Error</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> – predictions</p></li>
<li><p><strong>target</strong> – ground truth values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean absolute error loss</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quapy.method.non_aggregative">
<span id="quapy-method-non-aggregative"></span><h2>quapy.method.non_aggregative<a class="headerlink" href="#module-quapy.method.non_aggregative" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quapy.method.non_aggregative.</span></span><span class="sig-name descname"><span class="pre">MaximumLikelihoodPrevalenceEstimation</span></span><a class="headerlink" href="#quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quapy.method.base.BaseQuantifier" title="quapy.method.base.BaseQuantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseQuantifier</span></code></a></p>
<p>The <cite>Maximum Likelihood Prevalence Estimation</cite> (MLPE) method is a lazy method that assumes there is no prior
probability shift between training and test instances (put it other way, that the i.i.d. assumpion holds).
The estimation of class prevalence values for any test sample is always (i.e., irrespective of the test sample
itself) the class prevalence seen during training. This method is considered to be a lower-bound quantifier that
any quantification method should beat.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="quapy.data.html#quapy.data.base.LabelledCollection" title="quapy.data.base.LabelledCollection"><span class="pre">LabelledCollection</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the training prevalence and stores it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – the training sample</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation.quantify">
<span class="sig-name descname"><span class="pre">quantify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quapy.method.non_aggregative.MaximumLikelihoodPrevalenceEstimation.quantify" title="Permalink to this definition">¶</a></dt>
<dd><p>Ignores the input instances and returns, as the class prevalence estimantes, the training prevalence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instances</strong> – array-like (ignored)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the class prevalence seen during training</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-quapy.method">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-quapy.method" title="Permalink to this heading">¶</a></h2>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">quapy.method package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-quapy.method.aggregative">quapy.method.aggregative</a></li>
<li><a class="reference internal" href="#module-quapy.method.base">quapy.method.base</a></li>
<li><a class="reference internal" href="#module-quapy.method.meta">quapy.method.meta</a></li>
<li><a class="reference internal" href="#module-quapy.method.neural">quapy.method.neural</a></li>
<li><a class="reference internal" href="#module-quapy.method.non_aggregative">quapy.method.non_aggregative</a></li>
<li><a class="reference internal" href="#module-quapy.method">Module contents</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="quapy.data.html"
                          title="previous chapter">quapy.data package</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/quapy.method.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quapy.data.html" title="quapy.data package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">QuaPy 0.1.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >quapy</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="quapy.html" >quapy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quapy.method package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Alejandro Moreo.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>